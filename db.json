{
  "posts": [
    {
      "id": 1,
      "title": "Какие типы данных существуют в JS?",
      "body": "В JavaScript есть 8 основных типов данных:\nСемь из них называют «примитивными» типами данных:\n \n1) number для любых чисел: целочисленных или чисел с плавающей точкой (целочисленные значения ограничены диапазоном ±(253-1));\n2) bigint для целых чисел произвольной длины.\n3) string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.\n4) boolean для true/false.\n5) null для неизвестных значений – отдельный тип, имеющий одно значение null.\n6) undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.\n7) symbol для уникальных идентификаторов в объекте.\n \nИ один не является «примитивным» и стоит особняком:\n8) object для более сложных структур данных.\n  \nОператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.\nИмеет две формы: typeof x или typeof(x).\nВозвращает строку с именем типа. Например, \"string\".\nДля null возвращается \"object\" – это ошибка в языке, на самом деле это не объект."
    },
    {
      "title": "В чем разница между операторами \"==\" и \"===\"?",
      "body": "При сравнении значений разных типов JavaScript приводит каждое из них к числу.\n\nНапример:\n( '2' > 1 ); // true, строка '2' становится числом 2\n( '01' == 1 ); // true, строка '01' становится числом 1\n\nОператор строгого равенства === проверяет равенство без приведения типов.",
      "id": 2
    },
    {
      "title": "Какими способами можно объявить переменную?",
      "body": "a = 5;\n\nvar b = 10;\n\nlet c = 'let';\n\nconst obj = {};\n\nПервые два имеют глобальную и функциональную области видимости и не имеют блочной (считаются устаревшими).",
      "id": 3
    },
    {
      "title": "В чем разница между null и undefined?",
      "body": "Оба варианта означают пустое значение.\n\nЕсли мы инициализируем переменную, но не указываем значение, туда помещается специальный маркер, который отображается при выводе на экран как undefined\n\nnull - же мы присваиваем самостоятельно. Специальное значение, обозначающие ничего, пусто или значение не известно.",
      "id": 4
    },
    {
      "title": "map, filter, reduce, forEach для чего нужны, особенности использования?\nКакие методы мутируют исходный массив?",
      "body": "Каждый из этих методов итерируются по массиву.\n\nВозвращают новый массив:\n\n-map(func ) – создаёт новый массив из результатов вызова func для каждого элемента.\n-filter(func )  – фильтрует элементы через функцию и отдаёт значения, при прохождении которых через функцию возвращается true.\n\nВозвращает результат выполнения:\n\n-reduce(func(acc, cur), initial)  – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.\n\nИтерируется по массиву:\n\nforEach() – вызывает func для каждого элемента. Ничего не возвращает.\n\n\nМетоды методы sort, reverse и splice изменяют исходный массив.",
      "id": 5
    },
    {
      "title": "Отличие стрелочных функций от функций объявленных через function?",
      "body": "1. В стрелочных функциях нельзя использовать ключевое слово arguments\n2. Синтаксис\n3. У стрелочных функций нет своего this. Если идет обращение к this, то оно берется снаружи\n4. Не могут быть вызваны с new",
      "id": 6
    },
    {
      "title": "Что такое замыкание?",
      "body": "Замыкание - это функция вместе со всеми внешними переменными, которые ей доступны. В JavaScript, все функции изначально являются замыканиями (есть только одно исключение new Function).\n\nТо есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.\n\nКогда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка НЕ на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.",
      "id": 7
    },
    {
      "title": "Что такое шаблонные литералы и для чего они нужны? ` `",
      "body": "1) Можно вставлять выражения при помощи ${}\n2) В них разрешен перенос строки",
      "id": 8
    },
    {
      "title": "Что такое Set и Map?",
      "body": "Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.\n\nМы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach.\n\nMap – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.\n\nДля перебора коллекции Map есть 3 метода:\nmap.keys() – возвращает итерируемый объект по ключам,\nmap.values() – возвращает итерируемый объект по значениям,\nmap.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.",
      "id": 9
    },
    {
      "title": "Как определить наличие свойства в объекте?",
      "body": "const obj = { a: 5, b: 'string' }\n\n1) obj.hasOwnProperty('a') // true\n\n2) \"b\" in obj // true",
      "id": 10
    },
    {
      "title": "Какие способы создания объекта вы знаете?",
      "body": "1) С помощью функций (конструктор)\n\nfunction User (name, surname) {\n....this.name = name\n........this.surname = surname\n}\n\nconst user = new User(\"Max\", \"Popov\")\nconsole.log(user)   // User {name: 'Max', 'Popov'}\n\n2) С помощью литеральной нотации\n\nconst myObj = {1: 'a', 2: 'b'}\n\n3) С помощью класса\n\nclass User {\n....constructor(name, surname) {\n........this.name = name\n........this.surname = surname\n....}\n}\n\nconst user = new User(\"Max\", \"Popov\")\nconsole.log(user)   // User {name: 'Max', 'Popov'}",
      "id": 11
    },
    {
      "title": "Какие значения будут являться falsy значениями?",
      "body": "В JS есть только 7 ложных значений:  \n\n1) false \n2) 0 \n3) \"\" \n4) undefined \n5) null \n6) NaN \n7) BigInt(0)",
      "id": 12
    },
    {
      "title": "Что такое Promise?",
      "body": "Promise - это специальный объект предназначенный для работы с асинхронным кодом и который содержит свое состояние. В начале pending(\"ожидание\"), затем - одно из: fulfilled (\"выполнено успешно\") или rejected (\"выполнено с ошибкой\").\n\nПромисы пришли на замену колбекам, с помощью которых работали с асинхронными действиями.\n\nnew Promise((resolve, reject) => {\n....setTimeout(() => resolve(\"value\"), 2000);\n})\n.finally(() => alert(\"Промис завершён\")) \n\n// срабатывает первым .then(result => alert(result));",
      "id": 13
    },
    {
      "title": "Как использовать async await для асинхронных запросов?",
      "body": "Функция обозначенная как async всегда вернет промис. Позволяет использовать await в теле этой функции.\n\nКлючевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:\n\nЕсли промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.\n\nИначе вернётся результат промиса.\n\nВместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.\n\nХотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например).",
      "id": 14
    },
    {
      "title": "Для чего нужен оператор спред (расширения) ... ?",
      "body": "Когда мы видим \"...\" в коде, это могут быть как остаточные параметры, так и оператор расширения.\n\nКак отличить их друг от друга:\nЕсли ... располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.\n\nЕсли ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.\n\n\nПолезно запомнить:\n\nОстаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.\nС помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.\n\nТак же оператор расширения нужен чтобы развернуть объект или массив. Сделать копию (неглубокую)",
      "id": 15
    },
    {
      "title": "Как избежать ссылочной зависимости при копировании объекта?",
      "body": "В JS существует функция для копирования объекта - assign. \n\nПоскольку все объекты являются ссылками, то функция создаст новый объект с теми же полями. НО если внутри исходного объекта находятся, какие то еще объекты, то ссылки на них будут сохранены.\n\nconst obj = { a: 1, b: { c: 3 } }\nconst copy = Object.assign({}, obj)\n\ncopy.b === obj.b // true\n\nЕсть костыльный способ, т.е. мы сначала объект парсим в JSON-строку, а потом обратно в JS-объект\n\nconst copy = JSON.parse(JSON.stringify(obj))\n\ncopy.b === obj.b // false\n\n\nСсылочная зависимость уходит. Но так же есть недостатки. Таким методом мы не сможем закодировать:\n\n- Свойства-функции (методы). sayHi() {}\n- Символьные свойства.\n- Свойства, содержащие undefined.\n- комментарии\n\nМы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.",
      "id": 16
    },
    {
      "title": "Как поменять контекст функции?",
      "body": "1) С помощью функции bind() - в которую параметром передаем контекст. bind - возвращает новую функцию с контекстом, который мы передали параметром.\n\nfunction fn() {\nreturn this\n}\n\nconst obj = {name: \"Alex\"}\n\nconst newFn = fn.bind(obj)\nconsole.log(newFn()) // {name: \"Alex\"}\n\n\n2) С помощью функции call() и apply()\n\nfn.call(obj, \"arg1\", \"arg2\") // {name: \"Alex\"}\nfn.apply(obj, [\"arg1\", \"arg2\"]) // {name: \"Alex\"}\n\nОни обе вызывают функцию и первым параметром принимают контекст, к которому необходимо привязать эту функцию.\n\nCall - принимает параметры в виде перечисления через запятую\nApply - принимает параметры, которые прокидывает в исходную функцию в виде массива (псевдомассива)",
      "id": 17
    },
    {
      "title": "Что такое тернарный оператор?",
      "body": "условие ? тогда :  иначе\n\nАналогичен if, else",
      "id": 18
    },
    {
      "title": "Что такое деструктуризация?",
      "body": "В JS есть две наиболее часто используемые структуры данных - это объект и массив.\n\nДеструктурирующие присваивание это специальный синтакисиc, который позволяет нам распаковать массивы или объекты в несколько переменных, так как иногда они более удобны.\n\nсинтаксис для объекта:\nlet {prop : varName = default, ...rest} = object\n\nCвойство prop объекта object здесь должно быть присвоено переменной varName. Если в объекте отсутствует такое свойство, переменной varName присваивается значение по умолчанию.\nСвойства, которые не были упомянуты, копируются в объект rest.\n\n\nСинтаксис для массива:\nlet [item1 = default, item2, ...rest] = array\n\nПервый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.\n\nТрюк обмена переменных\nlet guest = \"Jane\";\nlet admin = \"Pete\";\n\n[guest, admin] = [admin, guest];",
      "id": 19
    },
    {
      "title": "Какие способы работы с асинхронным кодом вы знаете?",
      "body": "1) Callback - функция обратного вызова\n2) Промисы \n3) Async / await",
      "id": 20
    },
    {
      "title": "e.preventDefault() и e.stopPropagination() для чего нужны?",
      "body": "В JS есть огромное кол-во событий, это нажатие на мышь, клавиатуру, движение мыши и т.д.\n\nИ многие из этих событий автоматически влекут за собой, какое то действие браузера. Например клик по ссылке - инициирует переход на новую страницу. Или \"отправить\" в форме, отправляет какие то данные на сервер (submit).\n\nИ чтобы эти действия по умолчанию браузера отменить и используется preventDefault()\n\ne.stopPropagination() - перестать слушать события родителя.\n\nНапример в блоке <div> есть кнопка. А на сам див повешен слушатель события нажатия на него (например alert), и чтобы не происходило всплытия, необходимо повесить на слушатель события кнопки stopPropagination()",
      "id": 21
    },
    {
      "title": "Как отслеживать и обрабатывать ошибки в JS?",
      "body": "Есть специальная конструкция try catch finally.\n\nКоторая позволяет обрабатывать ошибки и вместо падения приложения делать что-то более осмысленное.\nСначала выполняется код внутри блока try и если в нем нет ошибок, то catch игнорируется. Если же в try произошла ошибка, то этот блок прерывается и поток управления переходит в начало блока catch.\n\nПеременная error в блоке catch содержит объект ошибки с подробной информацией о произошедшем.\n\nОбъекты ошибок содержат следующие свойства:\nmessage – понятное человеку сообщение.\nname – строка с именем ошибки (имя конструктора ошибки).\nstack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.\n\nМы можем также генерировать собственные ошибки, используя оператор throw. Аргументом throw может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса Error. \n\nПроброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает, как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.\n\nДаже если у нас нет try..catch, большинство сред позволяют настроить «глобальный» обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.\n\nТак же существует необязательный блок finally. И он выполнится в любом случае. Независимо от того, произошла ошибка или нет.",
      "id": 22
    },
    {
      "title": "Что такое DOM дерево?",
      "body": "Основой HTML-документа являются теги.\nВ соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.\n\nВсе эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.\n\nКратко: DOM - это объектное представление HTML-документа в JS которое представлено в виде структуры данных дерево.",
      "id": 23
    },
    {
      "title": "Что такое прототипное наследование?",
      "body": "В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип».\n\nВ прототип можно добавлять методы и свойства. Создавать другие объекты на основе этого прототипа. И создаваемый объект автоматически унаследует свойства, своего прототипа. Если свойство в самом объекте отсутствует, то будет произведен поиск в его прототипе.\n\nСвойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.\nОдним из них является использование __proto__\n\nОбратите внимание, что __proto__ — не то же самое, что внутреннее свойство [[Prototype]]. Это геттер/сеттер для [[Prototype]]\n\nСвойство __proto__ немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции Object.getPrototypeOf/Object.setPrototypeOf вместо того, чтобы получать/устанавливать прототип.\n\nЦикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.",
      "id": 24
    }
  ],
  "comments": [],
  "profile": {
    "name": "typicode"
  }
}